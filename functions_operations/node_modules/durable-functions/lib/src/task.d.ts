import { RetryOptions } from ".";
import { IAction, CreateTimerAction, CallHttpAction } from "./classes";
import { TaskOrchestrationExecutor } from "./taskorchestrationexecutor";
import { DurableOrchestrationContext } from "./durableorchestrationcontext";
/**
 * @hidden
 * The states a task can be in
 */
export declare enum TaskState {
    Running = 0,
    Failed = 1,
    Completed = 2
}
/**
 * @hidden
 * A taskID, either a `string` for external events,
 * or either `false` or a `number` for un-awaited
 * and awaited tasks respectively.
 */
export declare type TaskID = number | string | false;
/**
 * @hidden
 * A backing action, either a proper action or "noOp" for an internal-only task
 */
export declare type BackingAction = IAction | "noOp";
/**
 * A Durable Functions Task.
 */
export interface Task {
    /**
     * Whether the task has completed. Note that completion is not
     * equivalent to success.
     */
    isCompleted: boolean;
    /**
     * Whether the task faulted in some way due to error.
     */
    isFaulted: boolean;
    /**
     * The result of the task, if completed. Otherwise `undefined`.
     */
    result?: unknown;
}
/**
 * Returned from [[DurableOrchestrationClient]].[[createTimer]] if the call is
 * not `yield`-ed. Represents a pending timer. See documentation on [[Task]]
 * for more information.
 *
 * All pending timers must be completed or canceled for an orchestration to
 * complete.
 *
 * @example Cancel a timer
 * ```javascript
 * // calculate expiration date
 * const timeoutTask = context.df.createTimer(expirationDate);
 *
 * // do some work
 *
 * if (!timeoutTask.isCompleted) {
 *     // An orchestration won't get marked as completed until all its scheduled
 *     // tasks have returned, or been cancelled. Therefore, it is important
 *     // to cancel timers when they're no longer needed
 *     timeoutTask.cancel();
 * }
 * ```
 *
 * @example Create a timeout
 * ```javascript
 * const now = Date.now();
 * const expiration = new Date(now.valueOf()).setMinutes(now.getMinutes() + 30);
 *
 * const timeoutTask = context.df.createTimer(expirationDate);
 * const otherTask = context.df.callActivity("DoWork");
 *
 * const winner = yield context.df.Task.any([timeoutTask, otherTask]);
 *
 * if (winner === otherTask) {
 *     // do some more work
 * }
 *
 * if (!timeoutTask.isCompleted) {
 *     // An orchestration won't get marked as completed until all its scheduled
 *     // tasks have returned, or been cancelled. Therefore, it is important
 *     // to cancel timers when they're no longer needed
 *     timeoutTask.cancel();
 * }
 * ```
 */
export interface TimerTask extends Task {
    /**
     * @returns Whether or not the timer has been canceled.
     */
    isCanceled: boolean;
    /**
     * Indicates the timer should be canceled. This request will execute on the
     * next `yield` or `return` statement.
     */
    cancel: () => void;
}
/**
 * @hidden
 * Base class for all Tasks, defines the basic state transitions for all tasks.
 */
export declare abstract class TaskBase {
    id: TaskID;
    protected action: BackingAction;
    state: TaskState;
    parent: CompoundTask | undefined;
    isPlayed: boolean;
    result: unknown;
    /**
     * @hidden
     *
     * Construct a task.
     * @param id
     *  The task's ID
     * @param action
     *  The task's backing action
     */
    constructor(id: TaskID, action: BackingAction);
    /** Get this task's backing action */
    get actionObj(): BackingAction;
    /** Get this task's current state */
    get stateObj(): TaskState;
    /** Whether this task is not in the Running state */
    get hasResult(): boolean;
    get isFaulted(): boolean;
    get isCompleted(): boolean;
    /** Change this task from the Running state to a completed state */
    private changeState;
    /** Attempt to set a result for this task, and notifies parents, if any */
    setValue(isError: boolean, value: unknown): void;
    /**
     * @hidden
     * Notifies this task's parents about its state change.
     */
    private propagate;
}
/**
 * @hidden
 *
 * A task created only to facilitate replay, it should not communicate any
 * actions to the DF extension.
 *
 * We internally track these kinds of tasks to reason over the completion of
 * DF APIs that decompose into smaller DF APIs that the user didn't explicitly
 * schedule.
 */
export declare class NoOpTask extends TaskBase {
    constructor();
}
/**
 * @hidden
 * A task that should result in an Action being communicated to the DF extension.
 */
export declare class DFTask extends TaskBase implements Task {
    protected action: IAction;
    alreadyScheduled: boolean;
    /** Get this task's backing action */
    get actionObj(): IAction;
}
/**
 * @hidden
 *
 * A task that depends on the completion of other (sub-) tasks.
 */
export declare abstract class CompoundTask extends DFTask {
    children: TaskBase[];
    protected action: IAction;
    protected firstError: Error | undefined;
    /**
     * @hidden
     * Construct a Compound Task.
     * Primarily sets the parent pointer of each sub-task to be `this`.
     *
     * @param children
     *  The sub-tasks that this task depends on
     * @param action
     *  An action representing this compound task
     */
    constructor(children: TaskBase[], action: IAction);
    /**
     * @hidden
     * Tries to set this task's result based on the completion of a sub-task
     * @param child
     *  A sub-task of this task.
     */
    handleCompletion(child: TaskBase): void;
    /**
     * @hidden
     *
     * Task-internal logic for setting this task's isPlayed flag
     */
    abstract trySetIsPlayed(): void;
    /**
     * @hidden
     *
     * Task-internal logic for attempting to set this tasks' result
     * after any of its sub-tasks completes.
     * @param child
     *  A sub-task
     */
    abstract trySetValue(child: TaskBase): void;
}
export declare class AtomicTask extends DFTask {
}
/**
 * @hidden
 * A timer task. This is the internal implementation to the user-exposed TimerTask interface, which
 * has a more restricted API.
 */
export declare class DFTimerTask extends AtomicTask implements TimerTask {
    id: TaskID;
    action: CreateTimerAction;
    /**
     * @hidden
     * Construct a Timer Task.
     *
     * @param id
     *  The task's ID
     * @param action
     *  The backing action of this task
     */
    constructor(id: TaskID, action: CreateTimerAction);
    /** Whether this timer task is canceled */
    get isCanceled(): boolean;
    /**
     * @hidden
     * Cancel this timer task.
     * It errors out if the task has already completed.
     */
    cancel(): void;
}
/**
 * @hidden
 *
 * A WhenAll task.
 */
export declare class WhenAllTask extends CompoundTask {
    children: TaskBase[];
    protected action: IAction;
    /**
     * @hidden
     * Construct a WhenAll task.
     *
     * @param children
     *  Sub-tasks to wait on.
     * @param action
     *  A the backing action representing this task.
     */
    constructor(children: TaskBase[], action: IAction);
    trySetIsPlayed(): void;
    /**
     * @hidden
     * Attempts to set a value to this task, given a completed sub-task
     *
     * @param child
     *  The sub-task that just completed
     */
    trySetValue(child: AtomicTask): void;
}
/**
 * @hidden
 *
 * A WhenAny task.
 */
export declare class WhenAnyTask extends CompoundTask {
    trySetIsPlayed(): void;
    /**
     * @hidden
     * Attempts to set a value to this task, given a completed sub-task
     *
     * @param child
     *  The sub-task that just completed
     */
    trySetValue(child: TaskBase): void;
}
/**
 * @hidden
 *
 * CallHttp Task with polling logic
 *
 * If the HTTP requests returns a 202 status code with a 'Location' header,
 * then a timer task is created, after which another HTTP request is made,
 * until a different status code is returned.
 *
 * Any other result from the HTTP requests is the result of the whole task.
 *
 * The duration of the timer is specified by the 'Retry-After' header (in seconds)
 * of the 202 response, or a default value specified by the durable extension is used.
 *
 */
export declare class CallHttpWithPollingTask extends CompoundTask {
    private readonly orchestrationContext;
    private readonly executor;
    protected action: CallHttpAction;
    private readonly defaultHttpAsyncRequestSleepDuration;
    constructor(id: TaskID, action: CallHttpAction, orchestrationContext: DurableOrchestrationContext, executor: TaskOrchestrationExecutor, defaultHttpAsyncRequestSleepTimeMillseconds: number);
    trySetIsPlayed(): void;
    trySetValue(child: TaskBase): void;
    private addNewChildren;
}
/**
 * @hidden
 *
 * A long Timer Task.
 *
 * This Task is created when a timer is created with a duration
 * longer than the maximum timer duration supported by storage infrastructure.
 *
 * It extends `WhenAllTask` because it decomposes into
 * several smaller sub-`TimerTask`s
 */
export declare class LongTimerTask extends WhenAllTask implements TimerTask {
    id: TaskID;
    action: CreateTimerAction;
    private readonly executor;
    private readonly maximumTimerDuration;
    private readonly orchestrationContext;
    private readonly longRunningTimerIntervalDuration;
    constructor(id: TaskID, action: CreateTimerAction, orchestrationContext: DurableOrchestrationContext, executor: TaskOrchestrationExecutor, maximumTimerLength: string, longRunningTimerIntervalLength: string);
    get isCanceled(): boolean;
    /**
     * @hidden
     * Cancel this timer task.
     * It errors out if the task has already completed.
     */
    cancel(): void;
    /**
     * @hidden
     * Attempts to set a value to this timer, given a completed sub-timer
     *
     * @param child
     * The sub-timer that just completed
     */
    trySetValue(child: DFTimerTask): void;
    private getNextTimerTask;
    private addNewChild;
}
/**
 * @hidden
 *
 * A `-WithRetry` Task.
 * It is modeled after a `WhenAllTask` because it decomposes
 * into several sub-tasks (a growing sequence of timers and atomic tasks)
 * that all need to complete before this task reaches an end-value.
 */
export declare class RetryableTask extends WhenAllTask {
    innerTask: DFTask;
    private retryOptions;
    private executor;
    private isWaitingOnTimer;
    private attemptNumber;
    private error;
    /**
     * @hidden
     * Construct a retriable task.
     *
     * @param innerTask
     *  The task representing the work to retry
     * @param retryOptions
     *  The retrying settings
     * @param executor
     *  The taskOrchestrationExecutor managing the replay,
     *  we use to to scheduling new tasks (timers and retries)
     */
    constructor(innerTask: DFTask, retryOptions: RetryOptions, executor: TaskOrchestrationExecutor);
    /**
     * @hidden
     * Attempts to set a value to this task, given a completed sub-task
     *
     * @param child
     *  The sub-task that just completed
     */
    trySetValue(child: TaskBase): void;
}
