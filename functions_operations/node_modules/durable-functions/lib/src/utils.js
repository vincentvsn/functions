"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Utils = void 0;
class Utils {
    static processInput(input) {
        if (typeof input === "string") {
            input = JSON.stringify(input);
        }
        return input;
    }
    static getInstancesOf(collection, abstractClass) {
        if (collection && abstractClass) {
            const candidateObjects = Object.values(collection).filter((value) => this.hasAllPropertiesOf(value, abstractClass));
            this.parseTimestampsAsDates(candidateObjects);
            return candidateObjects;
        }
        return [];
    }
    static getHrMilliseconds(times) {
        return times[0] * 1000 + times[1] / 1e6;
    }
    static hasStringProperty(obj, prop) {
        if (Utils.hasOwnProperty(obj, prop)) {
            const propKey = prop;
            const property = obj[propKey];
            const propertyIsString = typeof property === "string";
            return propertyIsString;
        }
        return false;
    }
    static hasOwnProperty(obj, prop) {
        return obj.hasOwnProperty(prop);
    }
    static parseTimestampsAsDates(obj) {
        if (typeof obj === "object" && obj != null) {
            if (this.hasOwnProperty(obj, "Timestamp") && typeof obj.Timestamp === "string") {
                obj.Timestamp = new Date(obj.Timestamp);
            }
            Object.values(obj).map((value) => {
                this.parseTimestampsAsDates(value);
            });
        }
    }
    static hasAllPropertiesOf(obj, refInstance) {
        return (typeof refInstance === "object" &&
            typeof obj === "object" &&
            obj !== null &&
            Object.keys(refInstance).every((key) => {
                return obj.hasOwnProperty(key);
            }));
    }
    static ensureNonNull(argument, message) {
        if (argument === undefined) {
            throw new TypeError(message);
        }
        return argument;
    }
    static sleep(delayInMilliseconds) {
        return __awaiter(this, void 0, void 0, function* () {
            yield new Promise((resolve) => setTimeout(resolve, delayInMilliseconds));
        });
    }
    static throwIfNotInstanceOf(value, name, refInstance, type) {
        if (!this.hasAllPropertiesOf(value, refInstance)) {
            throw new TypeError(`${name}: Expected object of type ${type} but got ${typeof value}; are you missing properties?`);
        }
    }
    static throwIfEmpty(value, name) {
        if (typeof value !== "string") {
            throw new TypeError(`${name}: Expected non-empty, non-whitespace string but got ${typeof value}`);
        }
        else if (value.trim().length < 1) {
            throw new Error(`${name}: Expected non-empty, non-whitespace string but got empty string`);
        }
    }
    static throwIfNotNumber(value, name) {
        if (typeof value !== "number") {
            throw new TypeError(`${name}: Expected number but got ${typeof value}`);
        }
    }
}
exports.Utils = Utils;
//# sourceMappingURL=utils.js.map