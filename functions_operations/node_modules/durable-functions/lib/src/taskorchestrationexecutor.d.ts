import { HistoryEvent, IAction, IOrchestrationFunctionContext } from "./classes";
import { TaskBase, NoOpTask, DFTask } from "./task";
import { ReplaySchema } from "./replaySchema";
/**
 * @hidden
 * Utility class to manage orchestration replay
 */
export declare class TaskOrchestrationExecutor {
    private context;
    private currentTask;
    private output;
    private exception;
    private orchestratorReturned;
    private generator;
    private deferredTasks;
    private sequenceNumber;
    private schemaVersion;
    willContinueAsNew: boolean;
    private actions;
    protected openTasks: Record<number | string, TaskBase>;
    protected openEvents: Record<number | string, TaskBase[]>;
    private eventToTaskValuePayload;
    constructor();
    /**
     * @hidden
     *
     * Initialize the task orchestration executor for a brand new orchestrator invocation.
     * To be called in ContinueAsNew scenarios as well.
     */
    private initialize;
    /**
     * @hidden
     *
     * Start an orchestration's execution, replaying based on the currently-available History.
     *
     * @param context
     *  The orchestration context
     * @param history
     *  The orchestration history
     * @param schemaVersion
     *  The OOProc output schema version expected by the DF extension
     * @param fn
     *  The user-code defining the orchestration
     *
     * @returns
     *  Returns void but communicates the resulting orchestrator state via the context object's handler
     */
    execute(context: IOrchestrationFunctionContext, history: HistoryEvent[], schemaVersion: ReplaySchema, fn: (context: IOrchestrationFunctionContext) => IterableIterator<unknown>): Promise<void>;
    /**
     * @hidden
     * Determine if the orchestrator should exit, either successfully or through an error.
     *
     * @returns
     *  True if the orchestration's invocation completed, or if an unhandled exception was thrown.
     *  False otherwise.
     */
    private isDoneExecuting;
    /**
     * @hidden
     * Determine if the current invocation has finished.
     *
     * @returns
     *  True if the orchestration reached a `return` statement, or a `continueAsNew`.
     *  False otherwise.
     */
    private hasCompletedSuccessfully;
    /**
     * @hidden
     * Processes a History event, often by either by updating some deterministic API value, updating
     * the state of a task, or resuming the user code.
     *
     * @param event
     *  The History event we're currently processing
     */
    private processEvent;
    /**
     * @hidden
     * Set a Task's result from a task-completion History event.
     *
     * @param event
     *  The History event containing task-completion information
     * @param isSuccess
     *  A flag indicating if the task failed or succeeded
     * @param idKey
     *  The property in the History event containing the Task's ID
     * @returns
     */
    private setTaskValue;
    /**
     * @hidden
     * Attempt to continue executing the orchestrator.
     */
    private tryResumingUserCode;
    /**
     * @hidden
     * Add an action to the user-defined actions list.
     * It ignores the request if the orchestrator has already
     * signaled a "ContinueAsNew" operation.
     *
     * @param action
     *  User-defined action to track
     */
    addToActions(action: IAction): void;
    recordFireAndForgetAction(action: IAction): void;
    /**
     * @hidden
     * Tracks this task as waiting for completion.
     * In the process, it assigns the task an ID if it doesn't have one already.
     *
     * @param task
     *  Task to add to open tasks or open events list
     */
    trackOpenTask(task: NoOpTask | DFTask): void;
    /**
     * @hidden
     * Marks the current task (and all its children if it is a compound task) as already scheduled.
     * If a task is already scheduled, its backing action should not be added to the actions array
     *
     * @param task The task to mark as already scheduled.
     */
    markAsScheduled(task: NoOpTask | DFTask): void;
}
