import { IAction, IOrchestratorState } from "./classes";
import { ReplaySchema } from "./replaySchema";
/** @hidden */
export declare class OrchestratorState implements IOrchestratorState {
    readonly isDone: boolean;
    readonly actions: IAction[][];
    readonly output: unknown;
    readonly error?: string;
    readonly customStatus?: unknown;
    readonly schemaVersion: ReplaySchema;
    /**
     * @hidden
     *
     * It flattens an array of actions.
     * By flatten, we mean that, in the presence of a compound action (WhenAll/WhenAny),
     * we recursively extract all of its sub-actions into a flat sequence which is then
     * put in-place of the original compound action.
     *
     * For example, given the array:
     *  [Activity, Activity, WhenAll(Activity, WhenAny(ExternalEvent, Activity))]
     * We obtain:
     *  [Activity, Activity, Activity, ExternalEvent, Activity]
     *
     * This is helpful in translating the representation of user actions in
     * the DF extension replay protocol V2 to V1.
     *
     * @param actions
     *  The array of actions to flatten
     * @returns
     *  The flattened array of actions.
     */
    private flattenCompoundActions;
    constructor(options: IOrchestratorState, _literalActions?: boolean);
}
