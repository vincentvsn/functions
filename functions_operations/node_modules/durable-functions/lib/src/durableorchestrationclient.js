"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DurableOrchestrationClient = exports.getClient = void 0;
const axios_1 = require("axios");
const cloneDeep = require("lodash/cloneDeep");
const process = require("process");
const url = require("url");
const validator_1 = require("validator");
const classes_1 = require("./classes");
const webhookutils_1 = require("./webhookutils");
const URL = url.URL;
function getClient(context) {
    let clientData = getClientData(context);
    if (!process.env.WEBSITE_HOSTNAME || process.env.WEBSITE_HOSTNAME.includes("0.0.0.0")) {
        clientData = correctClientData(clientData);
    }
    return new DurableOrchestrationClient(clientData);
}
exports.getClient = getClient;
function getClientData(context) {
    if (context.bindings) {
        const matchingInstances = Object.keys(context.bindings)
            .map((key) => context.bindings[key])
            .filter((val) => classes_1.OrchestrationClientInputData.isOrchestrationClientInputData(val));
        if (matchingInstances && matchingInstances.length > 0) {
            return matchingInstances[0];
        }
    }
    throw new Error("An orchestration client function must have an orchestrationClient input binding. Check your function.json definition.");
}
function correctClientData(clientData) {
    const returnValue = cloneDeep(clientData);
    returnValue.creationUrls = correctUrls(clientData.creationUrls);
    returnValue.managementUrls = correctUrls(clientData.managementUrls);
    return returnValue;
}
function correctUrls(obj) {
    const returnValue = cloneDeep(obj);
    const keys = Object.getOwnPropertyNames(obj);
    keys.forEach((key) => {
        const value = obj[key];
        if ((0, validator_1.isURL)(value, {
            protocols: ["http", "https"],
            require_tld: false,
            require_protocol: true,
        })) {
            const valueAsUrl = new url.URL(value);
            returnValue[key] = value.replace(valueAsUrl.origin, classes_1.Constants.DefaultLocalOrigin);
        }
    });
    return returnValue;
}
class DurableOrchestrationClient {
    constructor(clientData) {
        this.clientData = clientData;
        this.eventNamePlaceholder = "{eventName}";
        this.functionNamePlaceholder = "{functionName}";
        this.instanceIdPlaceholder = "[/{instanceId}]";
        this.reasonPlaceholder = "{text}";
        this.createdTimeFromQueryKey = "createdTimeFrom";
        this.createdTimeToQueryKey = "createdTimeTo";
        this.runtimeStatusQueryKey = "runtimeStatus";
        this.showHistoryQueryKey = "showHistory";
        this.showHistoryOutputQueryKey = "showHistoryOutput";
        this.showInputQueryKey = "showInput";
        this.urlValidationOptions = {
            protocols: ["http", "https"],
            require_tld: false,
            require_protocol: true,
            require_valid_protocol: true,
        };
        if (!clientData) {
            throw new TypeError(`clientData: Expected OrchestrationClientInputData but got ${typeof clientData}`);
        }
        this.axiosInstance = axios_1.default.create({
            validateStatus: (status) => status < 600,
            headers: {
                post: {
                    "Content-Type": "application/json",
                },
            },
            maxContentLength: Infinity,
            maxBodyLength: 5000000,
        });
        this.taskHubName = this.clientData.taskHubName;
        this.uniqueWebhookOrigins = this.extractUniqueWebhookOrigins(this.clientData);
    }
    createCheckStatusResponse(request, instanceId) {
        const httpManagementPayload = this.getClientResponseLinks(request, instanceId);
        return {
            status: 202,
            body: httpManagementPayload,
            headers: {
                "Content-Type": "application/json",
                Location: httpManagementPayload.statusQueryGetUri,
                "Retry-After": 10,
            },
        };
    }
    createHttpManagementPayload(instanceId) {
        return this.getClientResponseLinks(undefined, instanceId);
    }
    getStatus(instanceId, showHistory, showHistoryOutput, showInput) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = {
                instanceId,
                showHistory,
                showHistoryOutput,
                showInput,
            };
            const response = yield this.getStatusInternal(options);
            switch (response.status) {
                case 200:
                case 202:
                case 400:
                case 404:
                case 500:
                    return response.data;
                default:
                    return Promise.reject(this.createGenericError(response));
            }
        });
    }
    getStatusAll() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getStatusInternal({});
            switch (response.status) {
                case 200:
                    return response.data;
                default:
                    return Promise.reject(this.createGenericError(response));
            }
        });
    }
    getStatusBy(createdTimeFrom, createdTimeTo, runtimeStatus) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = {
                createdTimeFrom,
                createdTimeTo,
                runtimeStatus,
            };
            const response = yield this.getStatusInternal(options);
            switch (response.status) {
                case 200:
                    return response.data;
                default:
                    return Promise.reject(this.createGenericError(response));
            }
        });
    }
    purgeInstanceHistory(instanceId) {
        return __awaiter(this, void 0, void 0, function* () {
            let requestUrl;
            if (this.clientData.rpcBaseUrl) {
                requestUrl = new URL(`instances/${instanceId}`, this.clientData.rpcBaseUrl).href;
            }
            else {
                const template = this.clientData.managementUrls.purgeHistoryDeleteUri;
                const idPlaceholder = this.clientData.managementUrls.id;
                requestUrl = template.replace(idPlaceholder, instanceId);
            }
            const response = yield this.axiosInstance.delete(requestUrl);
            switch (response.status) {
                case 200:
                    return response.data;
                case 404:
                    return new classes_1.PurgeHistoryResult(0);
                default:
                    return Promise.reject(this.createGenericError(response));
            }
        });
    }
    purgeInstanceHistoryBy(createdTimeFrom, createdTimeTo, runtimeStatus) {
        return __awaiter(this, void 0, void 0, function* () {
            let requestUrl;
            if (this.clientData.rpcBaseUrl) {
                let path = new URL("instances/", this.clientData.rpcBaseUrl).href;
                const query = [];
                if (createdTimeFrom) {
                    query.push(`createdTimeFrom=${createdTimeFrom.toISOString()}`);
                }
                if (createdTimeTo) {
                    query.push(`createdTimeTo=${createdTimeTo.toISOString()}`);
                }
                if (runtimeStatus && runtimeStatus.length > 0) {
                    const statusList = runtimeStatus.map((value) => value.toString()).join(",");
                    query.push(`runtimeStatus=${statusList}`);
                }
                if (query.length > 0) {
                    path += "?" + query.join("&");
                }
                requestUrl = new URL(path, this.clientData.rpcBaseUrl).href;
            }
            else {
                const idPlaceholder = this.clientData.managementUrls.id;
                requestUrl = this.clientData.managementUrls.statusQueryGetUri.replace(idPlaceholder, "");
                if (!(createdTimeFrom instanceof Date)) {
                    throw new Error("createdTimeFrom must be a valid Date");
                }
                if (createdTimeFrom) {
                    requestUrl += `&${this.createdTimeFromQueryKey}=${createdTimeFrom.toISOString()}`;
                }
                if (createdTimeTo) {
                    requestUrl += `&${this.createdTimeToQueryKey}=${createdTimeTo.toISOString()}`;
                }
                if (runtimeStatus && runtimeStatus.length > 0) {
                    const statusesString = runtimeStatus
                        .map((value) => value.toString())
                        .reduce((acc, curr, i) => {
                        return acc + (i > 0 ? "," : "") + curr;
                    });
                    requestUrl += `&${this.runtimeStatusQueryKey}=${statusesString}`;
                }
            }
            const response = yield this.axiosInstance.delete(requestUrl);
            switch (response.status) {
                case 200:
                    return response.data;
                case 404:
                    return new classes_1.PurgeHistoryResult(0);
                default:
                    return Promise.reject(this.createGenericError(response));
            }
        });
    }
    raiseEvent(instanceId, eventName, eventData, taskHubName, connectionName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!eventName) {
                throw new Error("eventName must be a valid string.");
            }
            let requestUrl;
            if (this.clientData.rpcBaseUrl) {
                let path = `instances/${instanceId}/raiseEvent/${eventName}`;
                const query = [];
                if (taskHubName) {
                    query.push(`taskHub=${taskHubName}`);
                }
                if (connectionName) {
                    query.push(`connection=${connectionName}`);
                }
                if (query.length > 0) {
                    path += "?" + query.join("&");
                }
                requestUrl = new URL(path, this.clientData.rpcBaseUrl).href;
            }
            else {
                const idPlaceholder = this.clientData.managementUrls.id;
                requestUrl = this.clientData.managementUrls.sendEventPostUri
                    .replace(idPlaceholder, instanceId)
                    .replace(this.eventNamePlaceholder, eventName);
                if (taskHubName) {
                    requestUrl = requestUrl.replace(this.clientData.taskHubName, taskHubName);
                }
                if (connectionName) {
                    requestUrl = requestUrl.replace(/(connection=)([\w]+)/gi, "$1" + connectionName);
                }
            }
            const response = yield this.axiosInstance.post(requestUrl, JSON.stringify(eventData));
            switch (response.status) {
                case 202:
                case 410:
                    return;
                case 404:
                    return Promise.reject(new Error(`No instance with ID '${instanceId}' found.`));
                default:
                    return Promise.reject(this.createGenericError(response));
            }
        });
    }
    readEntityState(entityId, taskHubName, connectionName) {
        return __awaiter(this, void 0, void 0, function* () {
            let requestUrl;
            if (this.clientData.rpcBaseUrl) {
                let path = `entities/${entityId.name}/${entityId.key}`;
                const query = [];
                if (taskHubName) {
                    query.push(`taskHub=${taskHubName}`);
                }
                if (connectionName) {
                    query.push(`connection=${connectionName}`);
                }
                if (query.length > 0) {
                    path += "?" + query.join("&");
                }
                requestUrl = new URL(path, this.clientData.rpcBaseUrl).href;
            }
            else {
                if (!(this.clientData.baseUrl && this.clientData.requiredQueryStringParameters)) {
                    throw new Error("Cannot use the readEntityState API with this version of the Durable Task Extension.");
                }
                requestUrl = webhookutils_1.WebhookUtils.getReadEntityUrl(this.clientData.baseUrl, this.clientData.requiredQueryStringParameters, entityId.name, entityId.key, taskHubName, connectionName);
            }
            const response = yield this.axiosInstance.get(requestUrl);
            switch (response.status) {
                case 200:
                    return new classes_1.EntityStateResponse(true, response.data);
                case 404:
                    return new classes_1.EntityStateResponse(false);
                default:
                    return Promise.reject(this.createGenericError(response));
            }
        });
    }
    rewind(instanceId, reason, taskHubName, connectionName) {
        return __awaiter(this, void 0, void 0, function* () {
            const idPlaceholder = this.clientData.managementUrls.id;
            let requestUrl;
            if (this.clientData.rpcBaseUrl) {
                let path = `instances/${instanceId}/rewind?reason=${reason}`;
                const query = [];
                if (taskHubName) {
                    query.push(`taskHub=${taskHubName}`);
                }
                if (connectionName) {
                    query.push(`connection=${connectionName}`);
                }
                if (query.length > 0) {
                    path += "&" + query.join("&");
                }
                requestUrl = new URL(path, this.clientData.rpcBaseUrl).href;
            }
            else {
                requestUrl = this.clientData.managementUrls.rewindPostUri
                    .replace(idPlaceholder, instanceId)
                    .replace(this.reasonPlaceholder, reason);
            }
            const response = yield this.axiosInstance.post(requestUrl);
            switch (response.status) {
                case 202:
                    return;
                case 404:
                    return Promise.reject(new Error(`No instance with ID '${instanceId}' found.`));
                case 410:
                    return Promise.reject(new Error("The rewind operation is only supported on failed orchestration instances."));
                default:
                    return Promise.reject(this.createGenericError(response));
            }
        });
    }
    signalEntity(entityId, operationName, operationContent, taskHubName, connectionName) {
        return __awaiter(this, void 0, void 0, function* () {
            let requestUrl;
            if (this.clientData.rpcBaseUrl) {
                let path = `entities/${entityId.name}/${entityId.key}`;
                const query = [];
                if (operationName) {
                    query.push(`op=${operationName}`);
                }
                if (taskHubName) {
                    query.push(`taskHub=${taskHubName}`);
                }
                if (connectionName) {
                    query.push(`connection=${connectionName}`);
                }
                if (query.length > 0) {
                    path += "?" + query.join("&");
                }
                requestUrl = new URL(path, this.clientData.rpcBaseUrl).href;
            }
            else {
                if (!(this.clientData.baseUrl && this.clientData.requiredQueryStringParameters)) {
                    throw new Error("Cannot use the signalEntity API with this version of the Durable Task Extension.");
                }
                requestUrl = webhookutils_1.WebhookUtils.getSignalEntityUrl(this.clientData.baseUrl, this.clientData.requiredQueryStringParameters, entityId.name, entityId.key, operationName, taskHubName, connectionName);
            }
            const response = yield this.axiosInstance.post(requestUrl, JSON.stringify(operationContent));
            switch (response.status) {
                case 202:
                    return;
                default:
                    return Promise.reject(this.createGenericError(response));
            }
        });
    }
    startNew(orchestratorFunctionName, instanceId, input) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!orchestratorFunctionName) {
                throw new Error("orchestratorFunctionName must be a valid string.");
            }
            let requestUrl;
            if (this.clientData.rpcBaseUrl) {
                requestUrl = new URL(`orchestrators/${orchestratorFunctionName}${instanceId ? `/${instanceId}` : ""}`, this.clientData.rpcBaseUrl).href;
            }
            else {
                requestUrl = this.clientData.creationUrls.createNewInstancePostUri;
                requestUrl = requestUrl
                    .replace(this.functionNamePlaceholder, orchestratorFunctionName)
                    .replace(this.instanceIdPlaceholder, instanceId ? `/${instanceId}` : "");
            }
            const response = yield this.axiosInstance.post(requestUrl, input !== undefined ? JSON.stringify(input) : "");
            if (response.data && response.status <= 202) {
                return response.data.id;
            }
            else {
                return Promise.reject(this.createGenericError(response));
            }
        });
    }
    terminate(instanceId, reason) {
        return __awaiter(this, void 0, void 0, function* () {
            const idPlaceholder = this.clientData.managementUrls.id;
            let requestUrl;
            if (this.clientData.rpcBaseUrl) {
                requestUrl = new URL(`instances/${instanceId}/terminate?reason=${reason}`, this.clientData.rpcBaseUrl).href;
            }
            else {
                requestUrl = this.clientData.managementUrls.terminatePostUri
                    .replace(idPlaceholder, instanceId)
                    .replace(this.reasonPlaceholder, reason);
            }
            const response = yield this.axiosInstance.post(requestUrl);
            switch (response.status) {
                case 202:
                case 410:
                    return;
                case 404:
                    return Promise.reject(new Error(`No instance with ID '${instanceId}' found.`));
                default:
                    return Promise.reject(this.createGenericError(response));
            }
        });
    }
    waitForCompletionOrCreateCheckStatusResponse(request, instanceId, timeoutInMilliseconds = 10000, retryIntervalInMilliseconds = 1000) {
        return __awaiter(this, void 0, void 0, function* () {
            if (retryIntervalInMilliseconds > timeoutInMilliseconds) {
                throw new Error(`Total timeout ${timeoutInMilliseconds} (ms) should be bigger than retry timeout ${retryIntervalInMilliseconds} (ms)`);
            }
            const hrStart = process.hrtime();
            while (true) {
                const status = yield this.getStatus(instanceId);
                if (status) {
                    switch (status.runtimeStatus) {
                        case classes_1.OrchestrationRuntimeStatus.Completed:
                            return this.createHttpResponse(200, status.output);
                        case classes_1.OrchestrationRuntimeStatus.Canceled:
                        case classes_1.OrchestrationRuntimeStatus.Terminated:
                            return this.createHttpResponse(200, status);
                        case classes_1.OrchestrationRuntimeStatus.Failed:
                            return this.createHttpResponse(500, status);
                    }
                }
                const hrElapsed = process.hrtime(hrStart);
                const hrElapsedMilliseconds = classes_1.Utils.getHrMilliseconds(hrElapsed);
                if (hrElapsedMilliseconds < timeoutInMilliseconds) {
                    const remainingTime = timeoutInMilliseconds - hrElapsedMilliseconds;
                    yield classes_1.Utils.sleep(remainingTime > retryIntervalInMilliseconds
                        ? retryIntervalInMilliseconds
                        : remainingTime);
                }
                else {
                    return this.createCheckStatusResponse(request, instanceId);
                }
            }
        });
    }
    createHttpResponse(statusCode, body) {
        const bodyAsJson = JSON.stringify(body);
        return {
            status: statusCode,
            body: bodyAsJson,
            headers: {
                "Content-Type": "application/json",
            },
        };
    }
    getClientResponseLinks(request, instanceId) {
        const payload = Object.assign({}, this.clientData.managementUrls);
        Object.keys(payload).forEach((key) => {
            if (this.hasValidRequestUrl(request) &&
                (0, validator_1.isURL)(payload[key], this.urlValidationOptions)) {
                const requestUrl = new url.URL(request.url || request.http.url);
                const dataUrl = new url.URL(payload[key]);
                payload[key] = payload[key].replace(dataUrl.origin, requestUrl.origin);
            }
            payload[key] = payload[key].replace(this.clientData.managementUrls.id, instanceId);
        });
        return payload;
    }
    hasValidRequestUrl(request) {
        const isHttpRequest = request !== undefined && request.url !== undefined;
        const isIHttpRequest = request !== undefined && request.http !== undefined;
        return (isHttpRequest || (isIHttpRequest && request.http.url !== undefined));
    }
    extractUniqueWebhookOrigins(clientData) {
        const origins = this.extractWebhookOrigins(clientData.creationUrls).concat(this.extractWebhookOrigins(clientData.managementUrls));
        const uniqueOrigins = origins.reduce((acc, curr) => {
            if (acc.indexOf(curr) === -1) {
                acc.push(curr);
            }
            return acc;
        }, []);
        return uniqueOrigins;
    }
    extractWebhookOrigins(obj) {
        const origins = [];
        const keys = Object.getOwnPropertyNames(obj);
        keys.forEach((key) => {
            const value = obj[key];
            if ((0, validator_1.isURL)(value, this.urlValidationOptions)) {
                const valueAsUrl = new url.URL(value);
                const origin = valueAsUrl.origin;
                origins.push(origin);
            }
        });
        return origins;
    }
    getStatusInternal(options, continuationToken, prevData) {
        return __awaiter(this, void 0, void 0, function* () {
            let requestUrl;
            if (this.clientData.rpcBaseUrl) {
                let path = new URL(`instances/${options.instanceId || ""}`, this.clientData.rpcBaseUrl)
                    .href;
                const query = [];
                if (options.taskHubName) {
                    query.push(`taskHub=${options.taskHubName}`);
                }
                if (options.connectionName) {
                    query.push(`connection=${options.connectionName}`);
                }
                if (options.showHistory) {
                    query.push(`showHistory=${options.showHistory}`);
                }
                if (options.showHistoryOutput) {
                    query.push(`showHistoryOutput=${options.showHistoryOutput}`);
                }
                if (options.showInput) {
                    query.push(`showInput=${options.showInput}`);
                }
                if (options.createdTimeFrom) {
                    query.push(`createdTimeFrom=${options.createdTimeFrom.toISOString()}`);
                }
                if (options.createdTimeTo) {
                    query.push(`createdTimeTo=${options.createdTimeTo.toISOString()}`);
                }
                if (options.runtimeStatus && options.runtimeStatus.length > 0) {
                    const statusList = options.runtimeStatus
                        .map((value) => value.toString())
                        .join(",");
                    query.push(`runtimeStatus=${statusList}`);
                }
                if (query.length > 0) {
                    path += "?" + query.join("&");
                }
                requestUrl = new URL(path, this.clientData.rpcBaseUrl).href;
            }
            else {
                const template = this.clientData.managementUrls.statusQueryGetUri;
                const idPlaceholder = this.clientData.managementUrls.id;
                requestUrl = template.replace(idPlaceholder, typeof options.instanceId === "string" ? options.instanceId : "");
                if (options.taskHubName) {
                    requestUrl = requestUrl.replace(this.clientData.taskHubName, options.taskHubName);
                }
                if (options.connectionName) {
                    requestUrl = requestUrl.replace(/(connection=)([\w]+)/gi, "$1" + options.connectionName);
                }
                if (options.showHistory) {
                    requestUrl += `&${this.showHistoryQueryKey}=${options.showHistory}`;
                }
                if (options.showHistoryOutput) {
                    requestUrl += `&${this.showHistoryOutputQueryKey}=${options.showHistoryOutput}`;
                }
                if (options.createdTimeFrom) {
                    requestUrl += `&${this.createdTimeFromQueryKey}=${options.createdTimeFrom.toISOString()}`;
                }
                if (options.createdTimeTo) {
                    requestUrl += `&${this.createdTimeToQueryKey}=${options.createdTimeTo.toISOString()}`;
                }
                if (options.runtimeStatus && options.runtimeStatus.length > 0) {
                    const statusesString = options.runtimeStatus
                        .map((value) => value.toString())
                        .reduce((acc, curr, i) => {
                        return acc + (i > 0 ? "," : "") + curr;
                    });
                    requestUrl += `&${this.runtimeStatusQueryKey}=${statusesString}`;
                }
                if (typeof options.showInput === "boolean") {
                    requestUrl += `&${this.showInputQueryKey}=${options.showInput}`;
                }
            }
            let axiosConfig = undefined;
            if (continuationToken) {
                axiosConfig = {
                    headers: {
                        "x-ms-continuation-token": continuationToken,
                    },
                };
            }
            const response = this.axiosInstance.get(requestUrl, axiosConfig).then((httpResponse) => {
                const headers = httpResponse.headers;
                if (prevData) {
                    httpResponse.data = prevData.concat(httpResponse.data);
                }
                const token = headers["x-ms-continuation-token"];
                if (token) {
                    return this.getStatusInternal(options, token, httpResponse.data);
                }
                return httpResponse;
            });
            return response;
        });
    }
    createGenericError(response) {
        return new Error(`The operation failed with an unexpected status code: ${response.status}. Details: ${JSON.stringify(response.data)}`);
    }
}
exports.DurableOrchestrationClient = DurableOrchestrationClient;
//# sourceMappingURL=durableorchestrationclient.js.map