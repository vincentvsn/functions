"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RetryableTask = exports.LongTimerTask = exports.CallHttpWithPollingTask = exports.WhenAnyTask = exports.WhenAllTask = exports.DFTimerTask = exports.AtomicTask = exports.CompoundTask = exports.DFTask = exports.NoOpTask = exports.TaskBase = exports.TaskState = void 0;
const _1 = require(".");
const classes_1 = require("./classes");
const moment = require("moment");
var TaskState;
(function (TaskState) {
    TaskState[TaskState["Running"] = 0] = "Running";
    TaskState[TaskState["Failed"] = 1] = "Failed";
    TaskState[TaskState["Completed"] = 2] = "Completed";
})(TaskState = exports.TaskState || (exports.TaskState = {}));
class TaskBase {
    constructor(id, action) {
        this.id = id;
        this.action = action;
        this.state = TaskState.Running;
        this.isPlayed = false;
    }
    get actionObj() {
        return this.action;
    }
    get stateObj() {
        return this.state;
    }
    get hasResult() {
        return this.state !== TaskState.Running;
    }
    get isFaulted() {
        return this.state === TaskState.Failed;
    }
    get isCompleted() {
        return this.state === TaskState.Completed;
    }
    changeState(state) {
        if (state === TaskState.Running) {
            throw Error("Cannot change Task to the RUNNING state.");
        }
        this.state = state;
    }
    setValue(isError, value) {
        let newState;
        if (isError) {
            if (!(value instanceof Error)) {
                const errMessage = `Task ID ${this.id} failed but it's value was not an Exception`;
                throw new Error(errMessage);
            }
            newState = TaskState.Failed;
        }
        else {
            newState = TaskState.Completed;
        }
        this.changeState(newState);
        this.result = value;
        this.propagate();
    }
    propagate() {
        const hasCompleted = this.state !== TaskState.Running;
        if (hasCompleted && this.parent !== undefined) {
            this.parent.handleCompletion(this);
        }
    }
}
exports.TaskBase = TaskBase;
class NoOpTask extends TaskBase {
    constructor() {
        super(false, "noOp");
    }
}
exports.NoOpTask = NoOpTask;
class DFTask extends TaskBase {
    constructor() {
        super(...arguments);
        this.alreadyScheduled = false;
    }
    get actionObj() {
        return this.action;
    }
}
exports.DFTask = DFTask;
class CompoundTask extends DFTask {
    constructor(children, action) {
        super(false, action);
        this.children = children;
        this.action = action;
        children.map((c) => (c.parent = this));
        this.firstError = undefined;
        if (children.length == 0) {
            this.state = TaskState.Completed;
        }
        children.forEach((child) => {
            if (child.state != TaskState.Running) {
                this.handleCompletion(child);
            }
        });
    }
    handleCompletion(child) {
        this.trySetIsPlayed();
        this.trySetValue(child);
    }
}
exports.CompoundTask = CompoundTask;
class AtomicTask extends DFTask {
}
exports.AtomicTask = AtomicTask;
class DFTimerTask extends AtomicTask {
    constructor(id, action) {
        super(id, action);
        this.id = id;
        this.action = action;
    }
    get isCanceled() {
        return this.action.isCanceled;
    }
    cancel() {
        if (this.hasResult) {
            throw Error("Cannot cancel a completed task.");
        }
        this.action.isCanceled = true;
    }
}
exports.DFTimerTask = DFTimerTask;
class WhenAllTask extends CompoundTask {
    constructor(children, action) {
        super(children, action);
        this.children = children;
        this.action = action;
    }
    trySetIsPlayed() {
        this.isPlayed = this.children.every((c) => c.isPlayed);
    }
    trySetValue(child) {
        if (child.stateObj === TaskState.Completed) {
            if (this.children.every((c) => c.stateObj === TaskState.Completed)) {
                const results = this.children.map((c) => c.result);
                this.setValue(false, results);
            }
        }
        else {
            if (this.firstError === undefined) {
                this.firstError = child.result;
                this.setValue(true, this.firstError);
            }
        }
    }
}
exports.WhenAllTask = WhenAllTask;
class WhenAnyTask extends CompoundTask {
    trySetIsPlayed() {
        this.isPlayed = this.children.some((c) => c.isPlayed);
    }
    trySetValue(child) {
        if (this.state === TaskState.Running) {
            this.setValue(false, child);
            this.isPlayed = child.isPlayed;
        }
    }
}
exports.WhenAnyTask = WhenAnyTask;
class CallHttpWithPollingTask extends CompoundTask {
    constructor(id, action, orchestrationContext, executor, defaultHttpAsyncRequestSleepTimeMillseconds) {
        super([new AtomicTask(id, action)], action);
        this.orchestrationContext = orchestrationContext;
        this.executor = executor;
        this.id = id;
        this.action = action;
        this.defaultHttpAsyncRequestSleepDuration = moment.duration(defaultHttpAsyncRequestSleepTimeMillseconds, "ms");
    }
    trySetIsPlayed() {
        const isPlayed = this.children.every((c) => c.isPlayed);
        this.isPlayed = isPlayed;
    }
    trySetValue(child) {
        if (child.stateObj === TaskState.Completed) {
            if (child.actionObj instanceof classes_1.CallHttpAction) {
                const resultObj = child.result;
                const result = new _1.DurableHttpResponse(resultObj.statusCode, resultObj.content, resultObj.headers);
                if (result.statusCode === 202 && result.getHeader("Location")) {
                    const retryAfterHeaderValue = result.getHeader("Retry-After");
                    const delay = retryAfterHeaderValue
                        ? moment.duration(retryAfterHeaderValue, "s")
                        : this.defaultHttpAsyncRequestSleepDuration;
                    const currentTime = this.orchestrationContext.currentUtcDateTime;
                    const timerFireTime = moment(currentTime).add(delay).toDate();
                    const timerTask = this.orchestrationContext.createTimer(timerFireTime);
                    const callHttpTask = new AtomicTask(false, new classes_1.CallHttpAction(this.action.httpRequest));
                    this.addNewChildren([timerTask, callHttpTask]);
                }
                else {
                    this.setValue(false, result);
                }
            }
        }
        else {
            if (this.firstError === undefined) {
                this.firstError = child.result;
                this.setValue(true, this.firstError);
            }
        }
    }
    addNewChildren(children) {
        children.map((child) => {
            child.parent = this;
            this.children.push(child);
            this.executor.trackOpenTask(child);
        });
    }
}
exports.CallHttpWithPollingTask = CallHttpWithPollingTask;
class LongTimerTask extends WhenAllTask {
    constructor(id, action, orchestrationContext, executor, maximumTimerLength, longRunningTimerIntervalLength) {
        const maximumTimerDuration = moment.duration(maximumTimerLength);
        const longRunningTimerIntervalDuration = moment.duration(longRunningTimerIntervalLength);
        const currentTime = orchestrationContext.currentUtcDateTime;
        const finalFireTime = action.fireAt;
        const durationUntilFire = moment.duration(moment(finalFireTime).diff(currentTime));
        const nextFireTime = durationUntilFire > maximumTimerDuration
            ? moment(currentTime).add(longRunningTimerIntervalDuration).toDate()
            : finalFireTime;
        const nextTimerAction = new classes_1.CreateTimerAction(nextFireTime);
        const nextTimerTask = new DFTimerTask(false, nextTimerAction);
        super([nextTimerTask], action);
        this.id = id;
        this.action = action;
        this.orchestrationContext = orchestrationContext;
        this.executor = executor;
        this.maximumTimerDuration = maximumTimerDuration;
        this.longRunningTimerIntervalDuration = longRunningTimerIntervalDuration;
    }
    get isCanceled() {
        return this.action.isCanceled;
    }
    cancel() {
        if (this.hasResult) {
            throw Error("Cannot cancel a completed task.");
        }
        this.action.isCanceled = true;
    }
    trySetValue(child) {
        const currentTime = this.orchestrationContext.currentUtcDateTime;
        const finalFireTime = this.action.fireAt;
        if (finalFireTime > currentTime) {
            const nextTimer = this.getNextTimerTask(finalFireTime, currentTime);
            this.addNewChild(nextTimer);
        }
        super.trySetValue(child);
    }
    getNextTimerTask(finalFireTime, currentTime) {
        const durationUntilFire = moment.duration(moment(finalFireTime).diff(currentTime));
        const nextFireTime = durationUntilFire > this.maximumTimerDuration
            ? moment(currentTime).add(this.longRunningTimerIntervalDuration).toDate()
            : finalFireTime;
        return new DFTimerTask(false, new classes_1.CreateTimerAction(nextFireTime));
    }
    addNewChild(childTimer) {
        childTimer.parent = this;
        this.children.push(childTimer);
        this.executor.trackOpenTask(childTimer);
    }
}
exports.LongTimerTask = LongTimerTask;
class RetryableTask extends WhenAllTask {
    constructor(innerTask, retryOptions, executor) {
        super([innerTask], innerTask.actionObj);
        this.innerTask = innerTask;
        this.retryOptions = retryOptions;
        this.executor = executor;
        this.attemptNumber = 1;
        this.isWaitingOnTimer = false;
    }
    trySetValue(child) {
        if (this.isWaitingOnTimer) {
            this.isWaitingOnTimer = false;
            if (this.attemptNumber > this.retryOptions.maxNumberOfAttempts) {
                this.setValue(true, this.error);
            }
            else {
                const rescheduledTask = new NoOpTask();
                rescheduledTask.parent = this;
                this.children.push(rescheduledTask);
                this.executor.trackOpenTask(rescheduledTask);
            }
        }
        else if (child.stateObj === TaskState.Completed) {
            this.setValue(false, child.result);
        }
        else {
            const rescheduledTask = new NoOpTask();
            rescheduledTask.parent = this;
            this.children.push(rescheduledTask);
            this.executor.trackOpenTask(rescheduledTask);
            this.isWaitingOnTimer = true;
            this.error = child.result;
            this.attemptNumber++;
        }
    }
}
exports.RetryableTask = RetryableTask;
//# sourceMappingURL=task.js.map