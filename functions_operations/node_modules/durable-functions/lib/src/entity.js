"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Entity = void 0;
const debug = require("debug");
const classes_1 = require("./classes");
const durableentitybindinginfo_1 = require("./durableentitybindinginfo");
const log = debug("orchestrator");
class Entity {
    constructor(fn) {
        this.fn = fn;
    }
    listen() {
        return this.handle.bind(this);
    }
    handle(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const entityBinding = classes_1.Utils.getInstancesOf(context.bindings, new durableentitybindinginfo_1.DurableEntityBindingInfoReqFields(new classes_1.EntityId("samplename", "samplekey"), true, []))[0];
            if (entityBinding === undefined) {
                throw new Error("Could not find an entityTrigger binding on context.");
            }
            const returnState = new classes_1.EntityState([], []);
            returnState.entityExists = entityBinding.exists;
            returnState.entityState = entityBinding.state;
            for (let i = 0; i < entityBinding.batch.length; i++) {
                const startTime = new Date();
                context.df = this.getCurrentDurableEntityContext(entityBinding, returnState, i, startTime);
                try {
                    yield Promise.resolve(this.fn(context));
                    if (!returnState.results[i]) {
                        const elapsedMs = this.computeElapsedMilliseconds(startTime);
                        returnState.results[i] = new classes_1.OperationResult(false, elapsedMs);
                    }
                }
                catch (error) {
                    const elapsedMs = this.computeElapsedMilliseconds(startTime);
                    returnState.results[i] = new classes_1.OperationResult(true, elapsedMs, JSON.stringify(error));
                }
            }
            context.suppressAsyncDoneError = true;
            context.done(null, returnState);
        });
    }
    getCurrentDurableEntityContext(bindingInfo, batchState, requestIndex, startTime) {
        const currentRequest = bindingInfo.batch[requestIndex];
        return {
            entityName: bindingInfo.self.name,
            entityKey: bindingInfo.self.key,
            entityId: bindingInfo.self,
            operationName: currentRequest.name,
            isNewlyConstructed: !batchState.entityExists,
            getState: this.getState.bind(this, batchState),
            setState: this.setState.bind(this, batchState),
            getInput: this.getInput.bind(this, currentRequest),
            return: this.return.bind(this, batchState, startTime),
            destructOnExit: this.destructOnExit.bind(this, batchState),
            signalEntity: this.signalEntity.bind(this, batchState),
        };
    }
    destructOnExit(batchState) {
        batchState.entityExists = false;
        batchState.entityState = undefined;
    }
    getInput(currentRequest) {
        if (currentRequest.input) {
            return JSON.parse(currentRequest.input);
        }
        return undefined;
    }
    getState(returnState, initializer) {
        if (returnState.entityState) {
            return JSON.parse(returnState.entityState);
        }
        else if (initializer) {
            return initializer();
        }
        return undefined;
    }
    return(returnState, startTime, result) {
        returnState.entityExists = true;
        returnState.results.push(new classes_1.OperationResult(false, this.computeElapsedMilliseconds(startTime), JSON.stringify(result)));
    }
    setState(returnState, state) {
        returnState.entityExists = true;
        returnState.entityState = JSON.stringify(state);
    }
    signalEntity(returnState, entity, operationName, operationInput) {
        returnState.signals.push(new classes_1.Signal(entity, operationName, operationInput ? JSON.stringify(operationInput) : ""));
    }
    computeElapsedMilliseconds(startTime) {
        const endTime = new Date();
        return endTime.getTime() - startTime.getTime();
    }
}
exports.Entity = Entity;
//# sourceMappingURL=entity.js.map